<!DOCTYPE html>
<meta charset="utf-8">
<style> /* set the CSS */

.line {
  fill: none;
  stroke-width: 2px;
  stroke-opacity:0.7;
}

.line_poly{
  fill: none ;
  stroke-width: 2px;
}

.area {
  fill: #94ffa2;
}

</style>
<body>

<!-- load the jquery library -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<!-- load the d3.js library -->    	
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="js/regression.js"></script>
<script src="js/polynomial.js"></script>
<script>

// set the dimensions and margins of the graph
var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = $(window).width()- margin.left - margin.right,
    height = $(window).height() / 2 - margin.top - margin.bottom;

// set the ranges
var x = d3.scaleLinear().range([0, width]); // age
var y = d3.scaleLinear().range([height, 0]); // bmi

// define the area
var area = d3.area()
    .x(function(d) { return x(d.age); })
    .y0(height)
    .y1(function(d) { return y(d.bmi); });

// define the line
var valueline = d3.line()
    .x(function(d) { return x(d.age); })
    .y(function(d) { return y(d.bmi); });

var color = d3.scaleOrdinal( d3['schemeCategory20'] ) ; 

var linePolynome = d3.line().curve(d3.curveCardinal);

// append the svg obgect to the body of the page
// appends a 'group' element to 'svg'
// moves the 'group' element to the top left margin
var svg_observed = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .attr('id','observed')
    .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

var svg_projected = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height - 10 + margin.top + margin.bottom)
    .attr('id','projected')
    .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

// get the data observed
d3.csv("data/MyDataRaw.csv", function(error, data) {

  if (error) throw error;
  var values = { 'x' : [] , 'y' : [] } ;
  // format the data
  data.forEach(function(d) {
      
      d.age = +d.age;
      d.bmi = +d.bmi;

      values.x.push( d.age );
      values.y.push( d.bmi );
  });

  var observed = d3.nest()
    .key( function(d){ return d.id })
    .entries( data ); 

  /*y.domain([15,d3.max(values.y)]); // bmi
  x.domain([20,d3.max(values.x)]);*/ // age

  y.domain([15,40]); // bmi
  x.domain([20,80]);

  svg_observed.append("g")
      .attr("transform", "translate(0," + height + ")")
      .call( d3.axisBottom(x) );

  // add the Y Axis
  svg_observed.append("g")
      .call( d3.axisLeft(y) );

  for( var l in observed )
  {
    svg_observed.append("path")
      .data([observed[l].values])
      .attr("class", function(d){ return "line line_"+d[0].id ; })
      .attr("d", valueline)
      .style('stroke',function(d,i){ 
          return color(l); 
      })
      .on('mouseover',function(d){
        d3.select(this).style('stroke-opacity',1) ; 
        d3.selectAll('.line_poly').style('stroke-opacity',0) ; 
        d3.selectAll('#line_poly_'+d.id).style('stroke','red');
      })
      .on('mouseout',function(d){
        d3.selectAll('.line_poly').style('stroke-opacity',0.7) ; 
        d3.selectAll('#line_poly_'+d.id).style('stroke','#cccccc');
      })
    ;
    break ; 
  }

  // get the data
  d3.csv("data/ModCoef.csv", function(error, polynomes) {

    if (error) throw error;
    // format the data
    polynomes.forEach(function(d) {
        
        d.a = +d.a;
        d.b = +d.b;
        d.c = +d.c; 
        
    });

    let polyReg = [] ; 
    let tmpVals = [] ; 

    for( var p in polynomes )
    {
      if( observed[p] == undefined ) continue ;   

      let vals = observed[p].values ; 
      let polynomial_values = [] ; 
      for ( var va in vals ) polynomial_values.push( [vals[va].bmi,vals[va].age] ) ; 

      let poly = polynomes[p] ; 
      //let polyReg = regression('polynomial', polynomial_values );
      //let polyReg = Polynomial([poly.c,poly.b,poly.a])

      tmpVals[p] = { 'id' : poly.id , 'values' : [] } ; 

      //let v = 20 ; 
      //tmpVals[p].values.push({ 'x' : v , 'y' : ( poly.a * Math.pow(v, 2) ) + poly.b * v + poly.c  }); 
    
      for(var j = 20; j <= 80 ; j++) 
      {
        //let v =  vals[j].bmi ; 

        tmpVals[p].values.push({
          'x' : j , 
          'y' : poly.a * Math.pow(j,2) + poly.b * j + poly.c , 
          //'y' : poly.a * Math.pow(v,2) + poly.b * v + poly.c , 
          //'y' : polyReg.equation[2] * Math.pow(v,2) + polyReg.equation[1] * v + polyReg.equation[0] , 
          //'y' : polyReg.eval(v) , 
          //'bmi' : v 
        }) ; 
      }

      //v = 70 ; 
      //tmpVals[p].values.push({ 'x' : v , 'y' : ( poly.a * Math.pow(v, 2) ) + poly.b * v + poly.c  }); 

      //console.info( poly.id ,   tmpVals[p].values ) ; 

      svg_projected.append("path")
        .datum( tmpVals[p].values )
        .attr("class", "line_poly")
        .style("stroke","#cccccc")
        .attr("id", function(d){ return 'line_poly_'+poly.id }) // assign ID
        .attr("d", d3.line()
           .curve( d3.curveCardinal )
           .x(function(d) { return x(d.x); })
           .y(function(d) { return y(d.y); })
       );

      break ; 
    }
      
    svg_projected.append("g")
      .attr("transform", "translate(0," + height + ")")
      .call( d3.axisBottom(x) );

    // add the Y Axis
    svg_projected.append("g")
        .call( d3.axisLeft(y) );

  });

});

function getPredicted (x, coefs) {
    // Get a predicted y value
    var pred = 0
    for(var i = 0; i < coefs.length; i++) {
        var dp = Math.pow(x, i)*coefs[i];
        pred += dp;
    }
    return (Math.exp(pred))
    // return (pred)
}



</script>
</body>
